/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-table";
exports.ids = ["vendor-chunks/micromark-extension-gfm-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./syntax */ \"(ssr)/./node_modules/micromark-extension-gfm-table/syntax.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsb0hBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXJlZmluZS1hcHAvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvaW5kZXguanM/YTI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3ludGF4JylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/syntax.js":
/*!**************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/syntax.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.flow = {\n  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}\n}\n\nvar createSpace = __webpack_require__(/*! micromark/dist/tokenize/factory-space */ \"(ssr)/./node_modules/micromark/dist/tokenize/factory-space.js\")\n\nvar setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}\nvar nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}\n\nfunction resolveTable(events, context) {\n  var length = events.length\n  var index = -1\n  var token\n  var inHead\n  var inDelimiterRow\n  var inRow\n  var cell\n  var content\n  var text\n  var contentStart\n  var contentEnd\n  var cellStart\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        }\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        length = events.length\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      length = events.length\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = []\n  var tableHeaderCount = 0\n  var seenDelimiter\n  var hasDash\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code)\n    }\n\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentHead(code)\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n\n    // If a setext heading, exit.\n    return effects.check(\n      setextUnderlineMini,\n      nok,\n      // Support an indent before the delimiter row.\n      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )\n  }\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)\n  }\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // We checked that it’s not a prefixed or blank line, so we’re certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4)\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      tableBodyContinue\n    )(code)\n  }\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // Support an optional prefix, then start a body row.\n    return createSpace(effects, rowStartBody, 'linePrefix', 4)\n  }\n}\n\n// Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0\n\n  return start\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === null || code < 0) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvc3ludGF4LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsNEdBQXVDOztBQUVqRSwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXJlZmluZS1hcHAvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvc3ludGF4LmpzPzhlNDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mbG93ID0ge1xuICBudWxsOiB7dG9rZW5pemU6IHRva2VuaXplVGFibGUsIHJlc29sdmU6IHJlc29sdmVUYWJsZSwgaW50ZXJydXB0aWJsZTogdHJ1ZX1cbn1cblxudmFyIGNyZWF0ZVNwYWNlID0gcmVxdWlyZSgnbWljcm9tYXJrL2Rpc3QvdG9rZW5pemUvZmFjdG9yeS1zcGFjZScpXG5cbnZhciBzZXRleHRVbmRlcmxpbmVNaW5pID0ge3Rva2VuaXplOiB0b2tlbml6ZVNldGV4dFVuZGVybGluZU1pbmksIHBhcnRpYWw6IHRydWV9XG52YXIgbmV4dFByZWZpeGVkT3JCbGFuayA9IHt0b2tlbml6ZTogdG9rZW5pemVOZXh0UHJlZml4ZWRPckJsYW5rLCBwYXJ0aWFsOiB0cnVlfVxuXG5mdW5jdGlvbiByZXNvbHZlVGFibGUoZXZlbnRzLCBjb250ZXh0KSB7XG4gIHZhciBsZW5ndGggPSBldmVudHMubGVuZ3RoXG4gIHZhciBpbmRleCA9IC0xXG4gIHZhciB0b2tlblxuICB2YXIgaW5IZWFkXG4gIHZhciBpbkRlbGltaXRlclJvd1xuICB2YXIgaW5Sb3dcbiAgdmFyIGNlbGxcbiAgdmFyIGNvbnRlbnRcbiAgdmFyIHRleHRcbiAgdmFyIGNvbnRlbnRTdGFydFxuICB2YXIgY29udGVudEVuZFxuICB2YXIgY2VsbFN0YXJ0XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChpblJvdykge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50Jykge1xuICAgICAgICBjb250ZW50U3RhcnQgPSBjb250ZW50U3RhcnQgfHwgaW5kZXhcbiAgICAgICAgY29udGVudEVuZCA9IGluZGV4XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ29tYmluZSBzZXBhcmF0ZSBjb250ZW50IHBhcnRzIGludG8gb25lLlxuICAgICAgICAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInIHx8IHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycpICYmXG4gICAgICAgIGNvbnRlbnRFbmRcbiAgICAgICkge1xuICAgICAgICBjb250ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZUNvbnRlbnQnLFxuICAgICAgICAgIHN0YXJ0OiBldmVudHNbY29udGVudFN0YXJ0XVsxXS5zdGFydCxcbiAgICAgICAgICBlbmQ6IGV2ZW50c1tjb250ZW50RW5kXVsxXS5lbmRcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0ge1xuICAgICAgICAgIHR5cGU6ICdjaHVua1RleHQnLFxuICAgICAgICAgIHN0YXJ0OiBjb250ZW50LnN0YXJ0LFxuICAgICAgICAgIGVuZDogY29udGVudC5lbmQsXG4gICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0J1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgICBjb250ZW50U3RhcnQsXG4gICAgICAgICAgY29udGVudEVuZCAtIGNvbnRlbnRTdGFydCArIDEsXG4gICAgICAgICAgWydlbnRlcicsIGNvbnRlbnQsIGNvbnRleHRdLFxuICAgICAgICAgIFsnZW50ZXInLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgICAgICBbJ2V4aXQnLCB0ZXh0LCBjb250ZXh0XSxcbiAgICAgICAgICBbJ2V4aXQnLCBjb250ZW50LCBjb250ZXh0XVxuICAgICAgICApXG4gICAgICAgIGluZGV4IC09IGNvbnRlbnRFbmQgLSBjb250ZW50U3RhcnQgLSAzXG4gICAgICAgIGxlbmd0aCA9IGV2ZW50cy5sZW5ndGhcbiAgICAgICAgY29udGVudFN0YXJ0ID0gdW5kZWZpbmVkXG4gICAgICAgIGNvbnRlbnRFbmQgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBldmVudHNbaW5kZXhdWzBdID09PSAnZXhpdCcgJiZcbiAgICAgIGNlbGxTdGFydCAmJlxuICAgICAgY2VsbFN0YXJ0ICsgMSA8IGluZGV4ICYmXG4gICAgICAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInIHx8XG4gICAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVSb3cnICYmXG4gICAgICAgICAgKGNlbGxTdGFydCArIDMgPCBpbmRleCB8fFxuICAgICAgICAgICAgZXZlbnRzW2NlbGxTdGFydF1bMV0udHlwZSAhPT0gJ3doaXRlc3BhY2UnKSkpXG4gICAgKSB7XG4gICAgICBjZWxsID0ge1xuICAgICAgICB0eXBlOiBpbkRlbGltaXRlclJvd1xuICAgICAgICAgID8gJ3RhYmxlRGVsaW1pdGVyJ1xuICAgICAgICAgIDogaW5IZWFkXG4gICAgICAgICAgPyAndGFibGVIZWFkZXInXG4gICAgICAgICAgOiAndGFibGVEYXRhJyxcbiAgICAgICAgc3RhcnQ6IGV2ZW50c1tjZWxsU3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgICBlbmQ6IGV2ZW50c1tpbmRleF1bMV0uZW5kXG4gICAgICB9XG4gICAgICBldmVudHMuc3BsaWNlKGluZGV4ICsgKHRva2VuLnR5cGUgPT09ICd0YWJsZUNlbGxEaXZpZGVyJyA/IDEgOiAwKSwgMCwgW1xuICAgICAgICAnZXhpdCcsXG4gICAgICAgIGNlbGwsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIF0pXG4gICAgICBldmVudHMuc3BsaWNlKGNlbGxTdGFydCwgMCwgWydlbnRlcicsIGNlbGwsIGNvbnRleHRdKVxuICAgICAgaW5kZXggKz0gMlxuICAgICAgbGVuZ3RoID0gZXZlbnRzLmxlbmd0aFxuICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycpIHtcbiAgICAgIGluUm93ID0gZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuXG4gICAgICBpZiAoaW5Sb3cpIHtcbiAgICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdycpIHtcbiAgICAgIGluRGVsaW1pdGVyUm93ID0gZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuXG4gICAgICBpZiAoaW5EZWxpbWl0ZXJSb3cpIHtcbiAgICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICBpbkhlYWQgPSBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuXG5mdW5jdGlvbiB0b2tlbml6ZVRhYmxlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgdmFyIGFsaWduID0gW11cbiAgdmFyIHRhYmxlSGVhZGVyQ291bnQgPSAwXG4gIHZhciBzZWVuRGVsaW1pdGVyXG4gIHZhciBoYXNEYXNoXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtIHVzZWQgdG8gYmUgcGFzc2VkIGluIGJldGEgbWljcm9tYXJrIHZlcnNpb25zLiAqL1xuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IC01IHx8IGNvZGUgPT09IC00IHx8IGNvZGUgPT09IC0zKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGUnKS5fYWxpZ24gPSBhbGlnblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuXG4gICAgLy8gSWYgd2Ugc3RhcnQgd2l0aCBhIHBpcGUsIHdlIG9wZW4gYSBjZWxsIG1hcmtlci5cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICByZXR1cm4gY2VsbERpdmlkZXJIZWFkKGNvZGUpXG4gICAgfVxuXG4gICAgdGFibGVIZWFkZXJDb3VudCsrXG4gICAgZWZmZWN0cy5lbnRlcigndGVtcG9yYXJ5VGFibGVDZWxsQ29udGVudCcpXG4gICAgLy8gQ2Fu4oCZdCBiZSBzcGFjZSBvciBlb2xzIGF0IHRoZSBzdGFydCBvZiBhIGNvbnN0cnVjdCwgc28gd2XigJlyZSBpbiBhIGNlbGwuXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRIZWFkKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiBjZWxsRGl2aWRlckhlYWQoY29kZSkge1xuICAgIC8vIEFsd2F5cyBhIHBpcGUuXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICBzZWVuRGVsaW1pdGVyID0gdHJ1ZVxuICAgIHJldHVybiBjZWxsQnJlYWtIZWFkXG4gIH1cblxuICBmdW5jdGlvbiBjZWxsQnJlYWtIZWFkKGNvZGUpIHtcbiAgICAvLyBFT0YsIENSLCBMRiwgQ1JMRi5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAtNSB8fCBjb2RlID09PSAtNCB8fCBjb2RlID09PSAtMykge1xuICAgICAgcmV0dXJuIGF0Um93RW5kSGVhZChjb2RlKVxuICAgIH1cblxuICAgIC8vIEhULCBWUywgU1AuXG4gICAgaWYgKGNvZGUgPT09IC0yIHx8IGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZUhlYWRcbiAgICB9XG5cbiAgICBpZiAoc2VlbkRlbGltaXRlcikge1xuICAgICAgc2VlbkRlbGltaXRlciA9IHVuZGVmaW5lZFxuICAgICAgdGFibGVIZWFkZXJDb3VudCsrXG4gICAgfVxuXG4gICAgLy8gYHxgXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVySGVhZChjb2RlKVxuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgIHJldHVybiBpbkNlbGxDb250ZW50SGVhZChjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5XaGl0ZXNwYWNlSGVhZChjb2RlKSB7XG4gICAgLy8gSFQsIFZTLCBTUC5cbiAgICBpZiAoY29kZSA9PT0gLTIgfHwgY29kZSA9PT0gLTEgfHwgY29kZSA9PT0gMzIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZUhlYWRcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3doaXRlc3BhY2UnKVxuICAgIHJldHVybiBjZWxsQnJlYWtIZWFkKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiBpbkNlbGxDb250ZW50SGVhZChjb2RlKSB7XG4gICAgLy8gRU9GLCB3aGl0ZXNwYWNlLCBwaXBlXG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA8IDAgfHwgY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTI0KSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgICAgcmV0dXJuIGNlbGxCcmVha0hlYWQoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAvLyBgXFxgXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gaW5DZWxsQ29udGVudEVzY2FwZUhlYWQgOiBpbkNlbGxDb250ZW50SGVhZFxuICB9XG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEVzY2FwZUhlYWQoY29kZSkge1xuICAgIC8vIGBcXGAgb3IgYHxgXG4gICAgaWYgKGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWRcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlLlxuICAgIHJldHVybiBpbkNlbGxDb250ZW50SGVhZChjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gYXRSb3dFbmRIZWFkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVIZWFkJylcblxuICAgIC8vIEFsd2F5cyBhIGxpbmUgZW5kaW5nLlxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG5cbiAgICAvLyBJZiBhIHNldGV4dCBoZWFkaW5nLCBleGl0LlxuICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgc2V0ZXh0VW5kZXJsaW5lTWluaSxcbiAgICAgIG5vayxcbiAgICAgIC8vIFN1cHBvcnQgYW4gaW5kZW50IGJlZm9yZSB0aGUgZGVsaW1pdGVyIHJvdy5cbiAgICAgIGNyZWF0ZVNwYWNlKGVmZmVjdHMsIHJvd1N0YXJ0RGVsaW1pdGVyLCAnbGluZVByZWZpeCcsIDQpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcm93U3RhcnREZWxpbWl0ZXIoY29kZSkge1xuICAgIC8vIElmIHRoZXJl4oCZcyBhbm90aGVyIHNwYWNlLCBvciB3ZeKAmXJlIGF0IHRoZSBFT0wvRU9GLCBleGl0LlxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPCAwIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgIHJldHVybiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpIHtcbiAgICAvLyBFT0YsIENSLCBMRiwgQ1JMRi5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAtNSB8fCBjb2RlID09PSAtNCB8fCBjb2RlID09PSAtMykge1xuICAgICAgcmV0dXJuIHJvd0VuZERlbGltaXRlcihjb2RlKVxuICAgIH1cblxuICAgIC8vIEhULCBWUywgU1AuXG4gICAgaWYgKGNvZGUgPT09IC0yIHx8IGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZURlbGltaXRlclxuICAgIH1cblxuICAgIC8vIGAtYFxuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBoYXNEYXNoID0gdHJ1ZVxuICAgICAgYWxpZ24ucHVzaChudWxsKVxuICAgICAgcmV0dXJuIGluRmlsbGVyRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgLy8gYDpgXG4gICAgaWYgKGNvZGUgPT09IDU4KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJBbGlnbm1lbnQnKVxuICAgICAgYWxpZ24ucHVzaCgnbGVmdCcpXG4gICAgICByZXR1cm4gYWZ0ZXJMZWZ0QWxpZ25tZW50XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugc3RhcnQgd2l0aCBhIHBpcGUsIHdlIG9wZW4gYSBjZWxsIG1hcmtlci5cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIHJldHVybiBhdERlbGltaXRlclJvd0JyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5XaGl0ZXNwYWNlRGVsaW1pdGVyKGNvZGUpIHtcbiAgICAvLyBIVCwgVlMsIFNQLlxuICAgIGlmIChjb2RlID09PSAtMiB8fCBjb2RlID09PSAtMSB8fCBjb2RlID09PSAzMikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVhayhjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5GaWxsZXJEZWxpbWl0ZXIoY29kZSkge1xuICAgIC8vIGAtYFxuICAgIGlmIChjb2RlID09PSA0NSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcblxuICAgIC8vIGA6YFxuICAgIGlmIChjb2RlID09PSA1OCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJBbGlnbm1lbnQnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcblxuICAgICAgYWxpZ25bYWxpZ24ubGVuZ3RoIC0gMV0gPVxuICAgICAgICBhbGlnblthbGlnbi5sZW5ndGggLSAxXSA9PT0gJ2xlZnQnID8gJ2NlbnRlcicgOiAncmlnaHQnXG5cbiAgICAgIHJldHVybiBhZnRlclJpZ2h0QWxpZ25tZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyTGVmdEFsaWdubWVudChjb2RlKSB7XG4gICAgLy8gYC1gXG4gICAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGhhc0Rhc2ggPSB0cnVlXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGlzIG5vdCBvay5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiBhZnRlclJpZ2h0QWxpZ25tZW50KGNvZGUpIHtcbiAgICAvLyBFT0YsIENSLCBMRiwgQ1JMRi5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSAtNSB8fCBjb2RlID09PSAtNCB8fCBjb2RlID09PSAtMykge1xuICAgICAgcmV0dXJuIHJvd0VuZERlbGltaXRlcihjb2RlKVxuICAgIH1cblxuICAgIC8vIEhULCBWUywgU1AuXG4gICAgaWYgKGNvZGUgPT09IC0yIHx8IGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd3aGl0ZXNwYWNlJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZURlbGltaXRlclxuICAgIH1cblxuICAgIC8vIGB8YFxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiByb3dFbmREZWxpbWl0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKVxuXG4gICAgLy8gRXhpdCBpZiB0aGVyZSB3YXMgbm8gZGFzaCBhdCBhbGwsIG9yIGlmIHRoZSBoZWFkZXIgY2VsbCBjb3VudCBpcyBub3QgdGhlXG4gICAgLy8gZGVsaW1pdGVyIGNlbGwgY291bnQuXG4gICAgaWYgKCFoYXNEYXNoIHx8IHRhYmxlSGVhZGVyQ291bnQgIT09IGFsaWduLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGFibGVDbG9zZShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKG5leHRQcmVmaXhlZE9yQmxhbmssIHRhYmxlQ2xvc2UsIHRhYmxlQ29udGludWUpKGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiB0YWJsZUNsb3NlKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlQ29udGludWUoY29kZSkge1xuICAgIC8vIEFsd2F5cyBhIGxpbmUgZW5kaW5nLlxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpbmVFbmRpbmcnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZycpXG4gICAgLy8gV2UgY2hlY2tlZCB0aGF0IGl04oCZcyBub3QgYSBwcmVmaXhlZCBvciBibGFuayBsaW5lLCBzbyB3ZeKAmXJlIGNlcnRhaW4gYVxuICAgIC8vIGJvZHkgaXMgY29taW5nLCB0aG91Z2ggaXQgbWF5IGJlIGluZGVudGVkLlxuICAgIHJldHVybiBjcmVhdGVTcGFjZShlZmZlY3RzLCBib2R5U3RhcnQsICdsaW5lUHJlZml4JywgNClcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvZHlTdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVCb2R5JylcbiAgICByZXR1cm4gcm93U3RhcnRCb2R5KGNvZGUpXG4gIH1cblxuICBmdW5jdGlvbiByb3dTdGFydEJvZHkoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlUm93JylcblxuICAgIC8vIElmIHdlIHN0YXJ0IHdpdGggYSBwaXBlLCB3ZSBvcGVuIGEgY2VsbCBtYXJrZXIuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIGNlbGxEaXZpZGVyQm9keShjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgIC8vIENhbuKAmXQgYmUgc3BhY2Ugb3IgZW9scyBhdCB0aGUgc3RhcnQgb2YgYSBjb25zdHJ1Y3QsIHNvIHdl4oCZcmUgaW4gYSBjZWxsLlxuICAgIHJldHVybiBpbkNlbGxDb250ZW50Qm9keShjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gY2VsbERpdmlkZXJCb2R5KGNvZGUpIHtcbiAgICAvLyBBbHdheXMgYSBwaXBlLlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgcmV0dXJuIGNlbGxCcmVha0JvZHlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbGxCcmVha0JvZHkoY29kZSkge1xuICAgIC8vIEVPRiwgQ1IsIExGLCBDUkxGLlxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IC01IHx8IGNvZGUgPT09IC00IHx8IGNvZGUgPT09IC0zKSB7XG4gICAgICByZXR1cm4gYXRSb3dFbmRCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgLy8gSFQsIFZTLCBTUC5cbiAgICBpZiAoY29kZSA9PT0gLTIgfHwgY29kZSA9PT0gLTEgfHwgY29kZSA9PT0gMzIpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3doaXRlc3BhY2UnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlQm9keVxuICAgIH1cblxuICAgIC8vIGB8YFxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckJvZHkoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGNlbGwgY29udGVudC5cbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZUJvZHkoY29kZSkge1xuICAgIC8vIEhULCBWUywgU1AuXG4gICAgaWYgKGNvZGUgPT09IC0yIHx8IGNvZGUgPT09IC0xIHx8IGNvZGUgPT09IDMyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VCb2R5XG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd3aGl0ZXNwYWNlJylcbiAgICByZXR1cm4gY2VsbEJyZWFrQm9keShjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEJvZHkoY29kZSkge1xuICAgIC8vIEVPRiwgd2hpdGVzcGFjZSwgcGlwZVxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPCAwIHx8IGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEyNCkge1xuICAgICAgZWZmZWN0cy5leGl0KCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAgIHJldHVybiBjZWxsQnJlYWtCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgLy8gYFxcYFxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IGluQ2VsbENvbnRlbnRFc2NhcGVCb2R5IDogaW5DZWxsQ29udGVudEJvZHlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluQ2VsbENvbnRlbnRFc2NhcGVCb2R5KGNvZGUpIHtcbiAgICAvLyBgXFxgIG9yIGB8YFxuICAgIGlmIChjb2RlID09PSA5MiB8fCBjb2RlID09PSAxMjQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5XG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZS5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0Um93RW5kQm9keShjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRhYmxlQm9keUNsb3NlKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICBuZXh0UHJlZml4ZWRPckJsYW5rLFxuICAgICAgdGFibGVCb2R5Q2xvc2UsXG4gICAgICB0YWJsZUJvZHlDb250aW51ZVxuICAgICkoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlQm9keUNsb3NlKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQm9keScpXG4gICAgcmV0dXJuIHRhYmxlQ2xvc2UoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlQm9keUNvbnRpbnVlKGNvZGUpIHtcbiAgICAvLyBBbHdheXMgYSBsaW5lIGVuZGluZy5cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIC8vIFN1cHBvcnQgYW4gb3B0aW9uYWwgcHJlZml4LCB0aGVuIHN0YXJ0IGEgYm9keSByb3cuXG4gICAgcmV0dXJuIGNyZWF0ZVNwYWNlKGVmZmVjdHMsIHJvd1N0YXJ0Qm9keSwgJ2xpbmVQcmVmaXgnLCA0KVxuICB9XG59XG5cbi8vIEJhc2VkIG9uIG1pY3JvbWFyaywgYnV0IHRoYXQgd29u4oCZdCB3b3JrIGFzIHdl4oCZcmUgaW4gYSB0YWJsZSwgYW5kIHRoYXQgZXhwZWN0c1xuLy8gY29udGVudC5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXJrL21pY3JvbWFyay9ibG9iL21haW4vbGliL3Rva2VuaXplL3NldGV4dC11bmRlcmxpbmUuanM+XG5mdW5jdGlvbiB0b2tlbml6ZVNldGV4dFVuZGVybGluZU1pbmkoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcblxuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gYC1gXG4gICAgaWYgKGNvZGUgIT09IDQ1KSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignc2V0ZXh0VW5kZXJsaW5lJylcbiAgICByZXR1cm4gc2VxdWVuY2UoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcXVlbmNlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHNlcXVlbmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHdoaXRlc3BhY2UoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHdoaXRlc3BhY2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAtMiB8fCBjb2RlID09PSAtMSB8fCBjb2RlID09PSAzMikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gd2hpdGVzcGFjZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsIHx8IGNvZGUgPT09IC01IHx8IGNvZGUgPT09IC00IHx8IGNvZGUgPT09IC0zKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5pemVOZXh0UHJlZml4ZWRPckJsYW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgdmFyIHNpemUgPSAwXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIC8vIFRoaXMgaXMgYSBjaGVjaywgc28gd2UgZG9u4oCZdCBjYXJlIGFib3V0IHRva2VucywgYnV0IHdlIG9wZW4gYSBib2d1cyBvbmVcbiAgICAvLyBzbyB3ZeKAmXJlIHZhbGlkLlxuICAgIGVmZmVjdHMuZW50ZXIoJ2NoZWNrJylcbiAgICAvLyBFT0wuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHdoaXRlc3BhY2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHdoaXRlc3BhY2UoY29kZSkge1xuICAgIC8vIFZTIG9yIFNQLlxuICAgIGlmIChjb2RlID09PSAtMSB8fCBjb2RlID09PSAzMikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBzaXplID09PSA0ID8gb2sgOiB3aGl0ZXNwYWNlXG4gICAgfVxuXG4gICAgLy8gRU9GIG9yIHdoaXRlc3BhY2VcbiAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlIDwgMCkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZS5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/syntax.js\n");

/***/ })

};
;