"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/markdown-table";
exports.ids = ["vendor-chunks/markdown-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/markdown-table/index.js":
/*!**********************************************!*\
  !*** ./node_modules/markdown-table/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar repeat = __webpack_require__(/*! repeat-string */ \"(ssr)/./node_modules/repeat-string/index.js\")\n\nmodule.exports = markdownTable\n\nvar trailingWhitespace = / +$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar colon = ':'\nvar verticalBar = '|'\n\nvar x = 0\nvar C = 67\nvar L = 76\nvar R = 82\nvar c = 99\nvar l = 108\nvar r = 114\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var padding = settings.padding !== false\n  var start = settings.delimiterStart !== false\n  var end = settings.delimiterEnd !== false\n  var align = (settings.align || []).concat()\n  var alignDelimiters = settings.alignDelimiters !== false\n  var alignments = []\n  var stringLength = settings.stringLength || defaultStringLength\n  var rowIndex = -1\n  var rowLength = table.length\n  var cellMatrix = []\n  var sizeMatrix = []\n  var row = []\n  var sizes = []\n  var longestCellByColumn = []\n  var mostCellsPerRow = 0\n  var cells\n  var columnIndex\n  var columnLength\n  var largest\n  var size\n  var cell\n  var lines\n  var line\n  var before\n  var after\n  var code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex]\n    columnIndex = -1\n    columnLength = cells.length\n    row = []\n    sizes = []\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex])\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        largest = longestCellByColumn[columnIndex]\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n  row = []\n  sizes = []\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === l) {\n      before = colon\n    } else if (code === r) {\n      after = colon\n    } else if (code === c) {\n      before = colon\n      after = colon\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters\n      ? Math.max(\n          1,\n          longestCellByColumn[columnIndex] - before.length - after.length\n        )\n      : 1\n\n    cell = before + repeat(dash, size) + after\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  rowLength = cellMatrix.length\n  lines = []\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    columnLength = mostCellsPerRow\n    line = []\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === r) {\n          before = repeat(space, size)\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2)\n            after = before\n          } else {\n            before = repeat(space, size / 2 + 0.5)\n            after = repeat(space, size / 2 - 0.5)\n          }\n        } else {\n          after = repeat(space, size)\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar)\n      }\n\n      if (\n        padding === true &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(alignDelimiters === false && cell === '') &&\n        (start === true || columnIndex !== 0)\n      ) {\n        line.push(space)\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (alignDelimiters === true) {\n        line.push(after)\n      }\n\n      if (padding === true) {\n        line.push(space)\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar)\n      }\n    }\n\n    line = line.join('')\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '')\n    }\n\n    lines.push(line)\n  }\n\n  return lines.join(lineFeed)\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\nfunction defaultStringLength(value) {\n  return value.length\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x\n\n  return code === L || code === l\n    ? l\n    : code === R || code === r\n    ? r\n    : code === C || code === c\n    ? c\n    : x\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFlOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXJlZmluZS1hcHAvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanM/ZWIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcmtkb3duVGFibGVcblxudmFyIHRyYWlsaW5nV2hpdGVzcGFjZSA9IC8gKyQvXG5cbi8vIENoYXJhY3RlcnMuXG52YXIgc3BhY2UgPSAnICdcbnZhciBsaW5lRmVlZCA9ICdcXG4nXG52YXIgZGFzaCA9ICctJ1xudmFyIGNvbG9uID0gJzonXG52YXIgdmVydGljYWxCYXIgPSAnfCdcblxudmFyIHggPSAwXG52YXIgQyA9IDY3XG52YXIgTCA9IDc2XG52YXIgUiA9IDgyXG52YXIgYyA9IDk5XG52YXIgbCA9IDEwOFxudmFyIHIgPSAxMTRcblxuLy8gQ3JlYXRlIGEgdGFibGUgZnJvbSBhIG1hdHJpeCBvZiBzdHJpbmdzLlxuZnVuY3Rpb24gbWFya2Rvd25UYWJsZSh0YWJsZSwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBwYWRkaW5nID0gc2V0dGluZ3MucGFkZGluZyAhPT0gZmFsc2VcbiAgdmFyIHN0YXJ0ID0gc2V0dGluZ3MuZGVsaW1pdGVyU3RhcnQgIT09IGZhbHNlXG4gIHZhciBlbmQgPSBzZXR0aW5ncy5kZWxpbWl0ZXJFbmQgIT09IGZhbHNlXG4gIHZhciBhbGlnbiA9IChzZXR0aW5ncy5hbGlnbiB8fCBbXSkuY29uY2F0KClcbiAgdmFyIGFsaWduRGVsaW1pdGVycyA9IHNldHRpbmdzLmFsaWduRGVsaW1pdGVycyAhPT0gZmFsc2VcbiAgdmFyIGFsaWdubWVudHMgPSBbXVxuICB2YXIgc3RyaW5nTGVuZ3RoID0gc2V0dGluZ3Muc3RyaW5nTGVuZ3RoIHx8IGRlZmF1bHRTdHJpbmdMZW5ndGhcbiAgdmFyIHJvd0luZGV4ID0gLTFcbiAgdmFyIHJvd0xlbmd0aCA9IHRhYmxlLmxlbmd0aFxuICB2YXIgY2VsbE1hdHJpeCA9IFtdXG4gIHZhciBzaXplTWF0cml4ID0gW11cbiAgdmFyIHJvdyA9IFtdXG4gIHZhciBzaXplcyA9IFtdXG4gIHZhciBsb25nZXN0Q2VsbEJ5Q29sdW1uID0gW11cbiAgdmFyIG1vc3RDZWxsc1BlclJvdyA9IDBcbiAgdmFyIGNlbGxzXG4gIHZhciBjb2x1bW5JbmRleFxuICB2YXIgY29sdW1uTGVuZ3RoXG4gIHZhciBsYXJnZXN0XG4gIHZhciBzaXplXG4gIHZhciBjZWxsXG4gIHZhciBsaW5lc1xuICB2YXIgbGluZVxuICB2YXIgYmVmb3JlXG4gIHZhciBhZnRlclxuICB2YXIgY29kZVxuXG4gIC8vIFRoaXMgaXMgYSBzdXBlcmZsdW91cyBsb29wIGlmIHdlIGRvbuKAmXQgYWxpZ24gZGVsaW1pdGVycywgYnV0IG90aGVyd2lzZSB3ZeKAmWRcbiAgLy8gZG8gc3VwZXJmbHVvdXMgd29yayB3aGVuIGFsaWduaW5nLCBzbyBvcHRpbWl6ZSBmb3IgYWxpZ25pbmcuXG4gIHdoaWxlICgrK3Jvd0luZGV4IDwgcm93TGVuZ3RoKSB7XG4gICAgY2VsbHMgPSB0YWJsZVtyb3dJbmRleF1cbiAgICBjb2x1bW5JbmRleCA9IC0xXG4gICAgY29sdW1uTGVuZ3RoID0gY2VsbHMubGVuZ3RoXG4gICAgcm93ID0gW11cbiAgICBzaXplcyA9IFtdXG5cbiAgICBpZiAoY29sdW1uTGVuZ3RoID4gbW9zdENlbGxzUGVyUm93KSB7XG4gICAgICBtb3N0Q2VsbHNQZXJSb3cgPSBjb2x1bW5MZW5ndGhcbiAgICB9XG5cbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IGNvbHVtbkxlbmd0aCkge1xuICAgICAgY2VsbCA9IHNlcmlhbGl6ZShjZWxsc1tjb2x1bW5JbmRleF0pXG5cbiAgICAgIGlmIChhbGlnbkRlbGltaXRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgc2l6ZSA9IHN0cmluZ0xlbmd0aChjZWxsKVxuICAgICAgICBzaXplc1tjb2x1bW5JbmRleF0gPSBzaXplXG5cbiAgICAgICAgbGFyZ2VzdCA9IGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdXG5cbiAgICAgICAgaWYgKGxhcmdlc3QgPT09IHVuZGVmaW5lZCB8fCBzaXplID4gbGFyZ2VzdCkge1xuICAgICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJvdy5wdXNoKGNlbGwpXG4gICAgfVxuXG4gICAgY2VsbE1hdHJpeFtyb3dJbmRleF0gPSByb3dcbiAgICBzaXplTWF0cml4W3Jvd0luZGV4XSA9IHNpemVzXG4gIH1cblxuICAvLyBGaWd1cmUgb3V0IHdoaWNoIGFsaWdubWVudHMgdG8gdXNlLlxuICBjb2x1bW5JbmRleCA9IC0xXG4gIGNvbHVtbkxlbmd0aCA9IG1vc3RDZWxsc1BlclJvd1xuXG4gIGlmICh0eXBlb2YgYWxpZ24gPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFsaWduKSB7XG4gICAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBjb2x1bW5MZW5ndGgpIHtcbiAgICAgIGFsaWdubWVudHNbY29sdW1uSW5kZXhdID0gdG9BbGlnbm1lbnQoYWxpZ25bY29sdW1uSW5kZXhdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdG9BbGlnbm1lbnQoYWxpZ24pXG5cbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IGNvbHVtbkxlbmd0aCkge1xuICAgICAgYWxpZ25tZW50c1tjb2x1bW5JbmRleF0gPSBjb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IHRoZSBhbGlnbm1lbnQgcm93LlxuICBjb2x1bW5JbmRleCA9IC0xXG4gIGNvbHVtbkxlbmd0aCA9IG1vc3RDZWxsc1BlclJvd1xuICByb3cgPSBbXVxuICBzaXplcyA9IFtdXG5cbiAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBjb2x1bW5MZW5ndGgpIHtcbiAgICBjb2RlID0gYWxpZ25tZW50c1tjb2x1bW5JbmRleF1cbiAgICBiZWZvcmUgPSAnJ1xuICAgIGFmdGVyID0gJydcblxuICAgIGlmIChjb2RlID09PSBsKSB7XG4gICAgICBiZWZvcmUgPSBjb2xvblxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gcikge1xuICAgICAgYWZ0ZXIgPSBjb2xvblxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gYykge1xuICAgICAgYmVmb3JlID0gY29sb25cbiAgICAgIGFmdGVyID0gY29sb25cbiAgICB9XG5cbiAgICAvLyBUaGVyZSAqbXVzdCogYmUgYXQgbGVhc3Qgb25lIGh5cGhlbi1taW51cyBpbiBlYWNoIGFsaWdubWVudCBjZWxsLlxuICAgIHNpemUgPSBhbGlnbkRlbGltaXRlcnNcbiAgICAgID8gTWF0aC5tYXgoXG4gICAgICAgICAgMSxcbiAgICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSAtIGJlZm9yZS5sZW5ndGggLSBhZnRlci5sZW5ndGhcbiAgICAgICAgKVxuICAgICAgOiAxXG5cbiAgICBjZWxsID0gYmVmb3JlICsgcmVwZWF0KGRhc2gsIHNpemUpICsgYWZ0ZXJcblxuICAgIGlmIChhbGlnbkRlbGltaXRlcnMgPT09IHRydWUpIHtcbiAgICAgIHNpemUgPSBiZWZvcmUubGVuZ3RoICsgc2l6ZSArIGFmdGVyLmxlbmd0aFxuXG4gICAgICBpZiAoc2l6ZSA+IGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgICAgfVxuXG4gICAgICBzaXplc1tjb2x1bW5JbmRleF0gPSBzaXplXG4gICAgfVxuXG4gICAgcm93W2NvbHVtbkluZGV4XSA9IGNlbGxcbiAgfVxuXG4gIC8vIEluamVjdCB0aGUgYWxpZ25tZW50IHJvdy5cbiAgY2VsbE1hdHJpeC5zcGxpY2UoMSwgMCwgcm93KVxuICBzaXplTWF0cml4LnNwbGljZSgxLCAwLCBzaXplcylcblxuICByb3dJbmRleCA9IC0xXG4gIHJvd0xlbmd0aCA9IGNlbGxNYXRyaXgubGVuZ3RoXG4gIGxpbmVzID0gW11cblxuICB3aGlsZSAoKytyb3dJbmRleCA8IHJvd0xlbmd0aCkge1xuICAgIHJvdyA9IGNlbGxNYXRyaXhbcm93SW5kZXhdXG4gICAgc2l6ZXMgPSBzaXplTWF0cml4W3Jvd0luZGV4XVxuICAgIGNvbHVtbkluZGV4ID0gLTFcbiAgICBjb2x1bW5MZW5ndGggPSBtb3N0Q2VsbHNQZXJSb3dcbiAgICBsaW5lID0gW11cblxuICAgIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgY29sdW1uTGVuZ3RoKSB7XG4gICAgICBjZWxsID0gcm93W2NvbHVtbkluZGV4XSB8fCAnJ1xuICAgICAgYmVmb3JlID0gJydcbiAgICAgIGFmdGVyID0gJydcblxuICAgICAgaWYgKGFsaWduRGVsaW1pdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBzaXplID0gbG9uZ2VzdENlbGxCeUNvbHVtbltjb2x1bW5JbmRleF0gLSAoc2l6ZXNbY29sdW1uSW5kZXhdIHx8IDApXG4gICAgICAgIGNvZGUgPSBhbGlnbm1lbnRzW2NvbHVtbkluZGV4XVxuXG4gICAgICAgIGlmIChjb2RlID09PSByKSB7XG4gICAgICAgICAgYmVmb3JlID0gcmVwZWF0KHNwYWNlLCBzaXplKVxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGMpIHtcbiAgICAgICAgICBpZiAoc2l6ZSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSA9IHJlcGVhdChzcGFjZSwgc2l6ZSAvIDIpXG4gICAgICAgICAgICBhZnRlciA9IGJlZm9yZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSByZXBlYXQoc3BhY2UsIHNpemUgLyAyICsgMC41KVxuICAgICAgICAgICAgYWZ0ZXIgPSByZXBlYXQoc3BhY2UsIHNpemUgLyAyIC0gMC41KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZnRlciA9IHJlcGVhdChzcGFjZSwgc2l6ZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IHRydWUgJiYgY29sdW1uSW5kZXggPT09IDApIHtcbiAgICAgICAgbGluZS5wdXNoKHZlcnRpY2FsQmFyKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHBhZGRpbmcgPT09IHRydWUgJiZcbiAgICAgICAgLy8gRG9u4oCZdCBhZGQgdGhlIG9wZW5pbmcgc3BhY2UgaWYgd2XigJlyZSBub3QgYWxpZ25pbmcgYW5kIHRoZSBjZWxsIGlzXG4gICAgICAgIC8vIGVtcHR5OiB0aGVyZSB3aWxsIGJlIGEgY2xvc2luZyBzcGFjZS5cbiAgICAgICAgIShhbGlnbkRlbGltaXRlcnMgPT09IGZhbHNlICYmIGNlbGwgPT09ICcnKSAmJlxuICAgICAgICAoc3RhcnQgPT09IHRydWUgfHwgY29sdW1uSW5kZXggIT09IDApXG4gICAgICApIHtcbiAgICAgICAgbGluZS5wdXNoKHNwYWNlKVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ25EZWxpbWl0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGxpbmUucHVzaChiZWZvcmUpXG4gICAgICB9XG5cbiAgICAgIGxpbmUucHVzaChjZWxsKVxuXG4gICAgICBpZiAoYWxpZ25EZWxpbWl0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGxpbmUucHVzaChhZnRlcilcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZGRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgbGluZS5wdXNoKHNwYWNlKVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSB0cnVlIHx8IGNvbHVtbkluZGV4ICE9PSBjb2x1bW5MZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmUucHVzaCh2ZXJ0aWNhbEJhcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lID0gbGluZS5qb2luKCcnKVxuXG4gICAgaWYgKGVuZCA9PT0gZmFsc2UpIHtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UodHJhaWxpbmdXaGl0ZXNwYWNlLCAnJylcbiAgICB9XG5cbiAgICBsaW5lcy5wdXNoKGxpbmUpXG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbihsaW5lRmVlZClcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmxlbmd0aFxufVxuXG5mdW5jdGlvbiB0b0FsaWdubWVudCh2YWx1ZSkge1xuICB2YXIgY29kZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5jaGFyQ29kZUF0KDApIDogeFxuXG4gIHJldHVybiBjb2RlID09PSBMIHx8IGNvZGUgPT09IGxcbiAgICA/IGxcbiAgICA6IGNvZGUgPT09IFIgfHwgY29kZSA9PT0gclxuICAgID8gclxuICAgIDogY29kZSA9PT0gQyB8fCBjb2RlID09PSBjXG4gICAgPyBjXG4gICAgOiB4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/markdown-table/index.js\n");

/***/ })

};
;