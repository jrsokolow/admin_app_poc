<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB vs LocalStorage Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid #e5e7eb;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background: #f9fafb;
        }

        .comparison-table .better {
            background: #d1fae5;
            font-weight: 600;
            color: #065f46;
        }

        .comparison-table .same {
            background: #fef3c7;
            color: #92400e;
        }

        .status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .status.active {
            background: #10b981;
            color: white;
        }

        .status.lost {
            background: #ef4444;
            color: white;
        }

        .demo-section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .demo-section h3 {
            color: #333;
            margin-bottom: 10px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        .storage-display {
            background: #1e293b;
            color: #10b981;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        .storage-display.empty {
            color: #ef4444;
        }

        .info-box {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
        }

        .info-box.warning {
            background: #fef3c7;
            border-left-color: #f59e0b;
        }

        .info-box.error {
            background: #fee2e2;
            border-left-color: #ef4444;
        }

        .info-box.success {
            background: #d1fae5;
            border-left-color: #10b981;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .code-block {
            background: #1e293b;
            color: #10b981;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }

        .metric {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-label {
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üóÑÔ∏è IndexedDB vs LocalStorage</h1>

        <!-- Comparison Table -->
        <div class="card">
            <h2>üìä Feature Comparison</h2>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>LocalStorage</th>
                        <th>IndexedDB</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Storage Limit</strong></td>
                        <td>~5-10 MB</td>
                        <td class="better">~50% of disk space (GBs)</td>
                    </tr>
                    <tr>
                        <td><strong>Data Type</strong></td>
                        <td>Strings only (JSON.stringify needed)</td>
                        <td class="better">Any JavaScript object</td>
                    </tr>
                    <tr>
                        <td><strong>API Style</strong></td>
                        <td class="better">Synchronous (simple)</td>
                        <td>Asynchronous (callbacks/Promises)</td>
                    </tr>
                    <tr>
                        <td><strong>Indexing</strong></td>
                        <td>No</td>
                        <td class="better">Yes (fast queries)</td>
                    </tr>
                    <tr>
                        <td><strong>Transactions</strong></td>
                        <td>No</td>
                        <td class="better">Yes (ACID-like)</td>
                    </tr>
                    <tr>
                        <td><strong>Large Files</strong></td>
                        <td>No (size limit)</td>
                        <td class="better">Yes (Blobs, Files)</td>
                    </tr>
                    <tr>
                        <td><strong>Complex Queries</strong></td>
                        <td>No (manual filtering)</td>
                        <td class="better">Yes (ranges, cursors)</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Fast (small data)</td>
                        <td class="better">Fast (large data)</td>
                    </tr>
                    <tr>
                        <td><strong>Learning Curve</strong></td>
                        <td class="better">Easy</td>
                        <td>Moderate</td>
                    </tr>
                    <tr>
                        <td><strong>Cleared When?</strong></td>
                        <td class="same">‚úÖ Same as IndexedDB</td>
                        <td class="same">‚úÖ Same as LocalStorage</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- When to Use -->
        <div class="card">
            <h2>üéØ When to Use Each</h2>
            <div class="grid">
                <div class="demo-section">
                    <h3>‚úÖ Use LocalStorage When:</h3>
                    <ul style="margin-left: 20px; line-height: 1.8;">
                        <li>Small data (< 5 MB)</li>
                        <li>Simple key-value pairs</li>
                        <li>User preferences</li>
                        <li>Simple caching</li>
                        <li>Quick implementation needed</li>
                    </ul>
                </div>
                <div class="demo-section">
                    <h3>‚úÖ Use IndexedDB When:</h3>
                    <ul style="margin-left: 20px; line-height: 1.8;">
                        <li>Large data (> 5 MB)</li>
                        <li>Complex data structures</li>
                        <li>Need indexing/queries</li>
                        <li>Storing files/blobs</li>
                        <li>Offline-first apps</li>
                        <li>Need transactions</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Important: Both Get Cleared -->
        <div class="card">
            <h2>‚ö†Ô∏è Critical: Both Get Cleared!</h2>
            <div class="info-box error">
                <strong>üö® Important:</strong> IndexedDB is cleared in the SAME scenarios as localStorage!
            </div>
            <div class="demo-section">
                <h3>Both are cleared when:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>üßπ User clears browsing data</li>
                    <li>üëª Incognito/private mode closes</li>
                    <li>üîí Browser reset/reinstall</li>
                    <li>üåê Different domain/subdomain</li>
                    <li>üíæ Storage quota exceeded (browser may clear)</li>
                    <li>üîß Programmatic clearing</li>
                </ul>
            </div>
            <div class="info-box warning">
                <strong>üí° Key Point:</strong> IndexedDB gives you MORE storage and BETTER features, but it's still client-side storage that can be cleared. Always have server-side backup for critical data!
            </div>
        </div>

        <!-- Live Demo -->
        <div class="card">
            <h2>üéÆ Live Demo</h2>
            <div class="grid">
                <div class="demo-section">
                    <h3>LocalStorage</h3>
                    <div class="status" id="lsStatus">Checking...</div>
                    <div class="storage-display" id="lsDisplay">Empty</div>
                    <div style="margin-top: 10px;">
                        <button onclick="saveToLS()" class="success">üíæ Save to LocalStorage</button>
                        <button onclick="clearLS()" class="danger">üóëÔ∏è Clear</button>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="lsSize">0</div>
                        <div class="metric-label">KB stored</div>
                    </div>
                </div>
                <div class="demo-section">
                    <h3>IndexedDB</h3>
                    <div class="status" id="idbStatus">Checking...</div>
                    <div class="storage-display" id="idbDisplay">Empty</div>
                    <div style="margin-top: 10px;">
                        <button onclick="saveToIDB()" class="success">üíæ Save to IndexedDB</button>
                        <button onclick="clearIDB()" class="danger">üóëÔ∏è Clear</button>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="idbSize">0</div>
                        <div class="metric-label">KB stored</div>
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="testLargeData()" style="background: #f59e0b;">üì¶ Test Large Data (1 MB)</button>
                <button onclick="testBothCleared()" class="danger">üßπ Simulate Clear Browsing Data</button>
            </div>
        </div>

        <!-- Code Examples -->
        <div class="card">
            <h2>üíª Code Examples</h2>
            
            <div class="demo-section">
                <h3>LocalStorage (Simple)</h3>
                <div class="code-block">
// Save
localStorage.setItem('key', JSON.stringify({name: 'John', age: 30}));

// Read
const data = JSON.parse(localStorage.getItem('key'));

// Delete
localStorage.removeItem('key');
                </div>
            </div>

            <div class="demo-section">
                <h3>IndexedDB (More Powerful)</h3>
                <div class="code-block">
// Open database
const request = indexedDB.open('MyDB', 1);

request.onupgradeneeded = (e) => {
    const db = e.target.result;
    const store = db.createObjectStore('users', {keyPath: 'id'});
    store.createIndex('name', 'name', {unique: false});
};

request.onsuccess = (e) => {
    const db = e.target.result;
    const tx = db.transaction('users', 'readwrite');
    const store = tx.objectStore('users');
    
    // Save
    store.add({id: 1, name: 'John', age: 30});
    
    // Read
    const getReq = store.get(1);
    getReq.onsuccess = () => {
        console.log(getReq.result);
    };
};
                </div>
            </div>
        </div>

        <!-- Storage Quota -->
        <div class="card">
            <h2>üíæ Storage Quota</h2>
            <div class="grid">
                <div class="metric">
                    <div class="metric-value" id="quotaUsage">0%</div>
                    <div class="metric-label">Quota Used</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="quotaAvailable">0 MB</div>
                    <div class="metric-label">Available</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="quotaTotal">0 MB</div>
                    <div class="metric-label">Total Quota</div>
                </div>
            </div>
            <button onclick="checkQuota()" style="width: 100%; margin-top: 15px;">üîç Check Storage Quota</button>
        </div>

        <!-- Best Practices -->
        <div class="card">
            <h2>‚úÖ Best Practices</h2>
            <div class="info-box">
                <strong>1. Choose the right tool</strong>
                <p style="margin-top: 5px;">Use localStorage for small, simple data. Use IndexedDB for large, complex data.</p>
            </div>
            <div class="info-box">
                <strong>2. Both can be cleared</strong>
                <p style="margin-top: 5px;">Neither localStorage nor IndexedDB is permanent. Always have server backup.</p>
            </div>
            <div class="info-box warning">
                <strong>3. Handle errors gracefully</strong>
                <p style="margin-top: 5px;">Both APIs can fail. Use try-catch and check availability.</p>
            </div>
            <div class="info-box success">
                <strong>4. Use IndexedDB for offline apps</strong>
                <p style="margin-top: 5px;">IndexedDB is perfect for Progressive Web Apps (PWAs) that work offline.</p>
            </div>
        </div>
    </div>

    <script>
        const DB_NAME = 'DemoDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'demoStore';
        let db = null;

        // Initialize IndexedDB
        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    document.getElementById('idbStatus').textContent = '‚ùå Not Available';
                    document.getElementById('idbStatus').className = 'status lost';
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    document.getElementById('idbStatus').textContent = '‚úÖ Available';
                    document.getElementById('idbStatus').className = 'status active';
                    resolve(db);
                };

                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, {keyPath: 'id', autoIncrement: true});
                    }
                };
            });
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            await initIndexedDB();
            refreshDisplays();
            checkQuota();
        });

        // LocalStorage functions
        function saveToLS() {
            try {
                const data = {
                    type: 'localStorage',
                    message: 'This is stored in localStorage',
                    timestamp: new Date().toISOString(),
                    data: 'x'.repeat(1000) // 1 KB
                };
                localStorage.setItem('demo_ls', JSON.stringify(data));
                refreshDisplays();
                showNotification('‚úÖ Saved to LocalStorage!', 'success');
            } catch (e) {
                showNotification('‚ùå Error: ' + e.message, 'error');
            }
        }

        function clearLS() {
            if (confirm('Clear LocalStorage?')) {
                localStorage.removeItem('demo_ls');
                refreshDisplays();
                showNotification('üóëÔ∏è LocalStorage cleared!', 'warning');
            }
        }

        // IndexedDB functions
        async function saveToIDB() {
            if (!db) {
                await initIndexedDB();
            }

            return new Promise((resolve, reject) => {
                const tx = db.transaction([STORE_NAME], 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                
                const data = {
                    type: 'indexedDB',
                    message: 'This is stored in IndexedDB',
                    timestamp: new Date().toISOString(),
                    data: 'x'.repeat(1000) // 1 KB
                };

                const request = store.add(data);
                
                request.onsuccess = () => {
                    refreshDisplays();
                    showNotification('‚úÖ Saved to IndexedDB!', 'success');
                    resolve();
                };
                
                request.onerror = () => {
                    showNotification('‚ùå Error: ' + request.error, 'error');
                    reject(request.error);
                };
            });
        }

        async function clearIDB() {
            if (!confirm('Clear IndexedDB?')) return;
            
            if (!db) {
                await initIndexedDB();
            }

            return new Promise((resolve, reject) => {
                const tx = db.transaction([STORE_NAME], 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.clear();

                request.onsuccess = () => {
                    refreshDisplays();
                    showNotification('üóëÔ∏è IndexedDB cleared!', 'warning');
                    resolve();
                };

                request.onerror = () => {
                    showNotification('‚ùå Error: ' + request.error, 'error');
                    reject(request.error);
                };
            });
        }

        // Refresh displays
        async function refreshDisplays() {
            // LocalStorage
            try {
                const lsData = localStorage.getItem('demo_ls');
                const lsDisplay = document.getElementById('lsDisplay');
                const lsStatus = document.getElementById('lsStatus');
                
                if (lsData) {
                    const parsed = JSON.parse(lsData);
                    lsDisplay.textContent = JSON.stringify(parsed, null, 2);
                    lsDisplay.className = 'storage-display';
                    lsStatus.textContent = '‚úÖ Has Data';
                    lsStatus.className = 'status active';
                    document.getElementById('lsSize').textContent = (new Blob([lsData]).size / 1024).toFixed(2);
                } else {
                    lsDisplay.textContent = 'Empty';
                    lsDisplay.className = 'storage-display empty';
                    lsStatus.textContent = '‚ùå Empty';
                    lsStatus.className = 'status lost';
                    document.getElementById('lsSize').textContent = '0';
                }
            } catch (e) {
                document.getElementById('lsDisplay').textContent = 'Error: ' + e.message;
            }

            // IndexedDB
            if (!db) {
                try {
                    await initIndexedDB();
                } catch (e) {
                    return;
                }
            }

            return new Promise((resolve) => {
                const tx = db.transaction([STORE_NAME], 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();

                request.onsuccess = () => {
                    const idbDisplay = document.getElementById('idbDisplay');
                    const idbStatus = document.getElementById('idbStatus');
                    const results = request.result;

                    if (results.length > 0) {
                        idbDisplay.textContent = JSON.stringify(results, null, 2);
                        idbDisplay.className = 'storage-display';
                        idbStatus.textContent = '‚úÖ Has Data (' + results.length + ' items)';
                        idbStatus.className = 'status active';
                        
                        const totalSize = results.reduce((sum, item) => {
                            return sum + new Blob([JSON.stringify(item)]).size;
                        }, 0);
                        document.getElementById('idbSize').textContent = (totalSize / 1024).toFixed(2);
                    } else {
                        idbDisplay.textContent = 'Empty';
                        idbDisplay.className = 'storage-display empty';
                        idbStatus.textContent = '‚ùå Empty';
                        idbStatus.className = 'status lost';
                        document.getElementById('idbSize').textContent = '0';
                    }
                    resolve();
                };

                request.onerror = () => {
                    document.getElementById('idbDisplay').textContent = 'Error: ' + request.error;
                    resolve();
                };
            });
        }

        // Test large data
        async function testLargeData() {
            if (!db) {
                await initIndexedDB();
            }

            const largeData = 'x'.repeat(1024 * 1024); // 1 MB

            // Try LocalStorage (will likely fail)
            try {
                localStorage.setItem('large_test', largeData);
                showNotification('‚úÖ LocalStorage accepted 1 MB!', 'success');
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    showNotification('‚ùå LocalStorage quota exceeded!', 'error');
                } else {
                    showNotification('‚ùå LocalStorage error: ' + e.message, 'error');
                }
            }

            // Try IndexedDB (should work)
            return new Promise((resolve) => {
                const tx = db.transaction([STORE_NAME], 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                
                const data = {
                    type: 'large',
                    size: '1 MB',
                    data: largeData,
                    timestamp: new Date().toISOString()
                };

                const request = store.add(data);
                
                request.onsuccess = () => {
                    showNotification('‚úÖ IndexedDB stored 1 MB successfully!', 'success');
                    refreshDisplays();
                    resolve();
                };
                
                request.onerror = () => {
                    showNotification('‚ùå IndexedDB error: ' + request.error, 'error');
                    resolve();
                };
            });
        }

        // Test both cleared
        function testBothCleared() {
            if (confirm('This will clear BOTH LocalStorage and IndexedDB to simulate clearing browsing data. Continue?')) {
                clearLS();
                clearIDB();
                setTimeout(() => {
                    showNotification('üßπ Both storages cleared! This is what happens when users clear browsing data.', 'warning');
                }, 500);
            }
        }

        // Check quota
        async function checkQuota() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 0;
                    const available = quota - usage;

                    document.getElementById('quotaUsage').textContent = 
                        ((usage / quota) * 100).toFixed(1) + '%';
                    document.getElementById('quotaAvailable').textContent = 
                        (available / 1024 / 1024).toFixed(2) + ' MB';
                    document.getElementById('quotaTotal').textContent = 
                        (quota / 1024 / 1024).toFixed(2) + ' MB';
                } catch (e) {
                    showNotification('‚ùå Error checking quota: ' + e.message, 'error');
                }
            } else {
                showNotification('‚ö†Ô∏è Storage quota API not available', 'warning');
            }
        }

        // Notification system
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#f59e0b'};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>



